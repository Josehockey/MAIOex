import numpy as npy
import math as math
import matplotlib.pyplot as plt
import os
# Solve linear shallow water equations in radial coordinate on a stretched grid, assuming axisymmetry

DirecOutputrend = "/Users/jose/Documents/SOAC_proj/END/r/"
DirecOutputvend = "/Users/jose/Documents/SOAC_proj/END/vm/"
DirecOutputpend = "/Users/jose/Documents/SOAC_proj/END/ps/"
DirecOutputend = "/Users/jose/Documents/SOAC_proj/END/"

###############################  INPUT PARAMETERS

#-----> Arts
Runnumber = 1 # number of the Run                                              
ntplot = 1800 # frequency of output in steps (-> Look at dt for conversion)
Ntest= 3 
ltest= 5*Ntest
#-----> Pysical
g = 9.81
f_cor = 0.0001   
eps = 0.9       # =ro2/ro1
ro1 = 1.0
ro2 = eps * ro1
Href = 5000.0   # reference depth fluid [m]
nlayer_len = 2

#-----> Forcing
Tf = 6
T_forcing= Tf * 3600.0 #time scale forcing [s]
a = 500000.0  # horizontal scale of the forcing [m]
Qmax = 0.4 * Href  # amplitude of forcing ("Diabatic mass flux")               #Unit do not metter, it's proportional to the volume.
r0 = 500000.0  # radius of maximum forcing [m]
Hpert = Qmax

#-----> Initial
RMW = 500000.0  # radius of maximum initial state (velocity)
v1max_i = 0.0  # max. tang. wind lower layer                                   
v2max_i = 0.0  # max. tang. wind upper layer

############################### GRIDS

#------> Time
dt = 1  # time step in seconds
end = 24*3600 # 24 total time of integration                                  
time = npy.arange(0, end, dt)           

#-----> Space
nx_len = 125 #number of points
dx = 1 #grid risolution							      #---> Keep dx fixed and moves the others parameters. 
labda = 0.05 # parameter stretched grid                                       ###SET UP : l=0.05 b = 8000.0 nx_len = 125 perfect for focus 4000km 
b = 20000.0 # parameter stretched grid                                         ###then increase lambda and decrease b to increase the focus power and vice versa

r = npy.zeros(nx_len)   # radial distance grid points u and v                  
c = npy.zeros(nx_len)                                                          
rm = npy.zeros(nx_len)  # radial distance grid points h 
cm = npy.zeros(nx_len)

for nx in range(0, nx_len):
   r[nx] = b * (math.exp(labda*nx) - 1)
   rm[nx] = b * (math.exp(labda*(nx+0.5)) - 1)  
   c[nx] = math.pow(labda*(r[nx]+b),-1)
   cm[nx] = math.pow(labda*(rm[nx]+b),-1)

#-----> Velocities
u = npy.zeros((len(time),nlayer_len,nx_len))
v = npy.zeros((len(time),nlayer_len,nx_len))
rv = npy.zeros((len(time),nlayer_len,nx_len))                                     ###WHAT'S THIS?  ---->(RELATIVE VORTICITY??)
zeta = npy.zeros((len(time),nlayer_len,nx_len))                                   ###AND THIS?     ---->(POTENTIAL VORTICITY??)
h = npy.zeros((len(time),nlayer_len,nx_len))
M = npy.zeros((len(time),nlayer_len,nx_len))
geopot = npy.zeros((len(time),nlayer_len,nx_len))

vgrad = npy.zeros((nlayer_len,nx_len))       #--> Time indipendent 
ps0 = npy.zeros([ltest,len(time)])                   #--> Timeseries of pressure in the centre
vmax = npy.zeros([ltest,len(time)])                   #--> Timeseries of maximum v
rvmax = npy.zeros([ltest,len(time)])                   #--> Timeseries of maximum v location
###################### INITIAL CONDITIONS
for test in range(0,ltest):
    Tf = 6
    T_forcing= Tf * 3600.0 
    a = 500000.0  
    Qmax = 0.4 * Href  
    r0 = 500000.0  
    RMW = 500000.0 
    if test<3:
        Tf = 5+test
        T_forcing= Tf * 3600.0
    if 2<test<6:
        testn=test-3
        a = 400000.0 + 200000.0*testn
    if 5<test<9:
        testn=test-6
        Qu = 0.2 + 0.2*testn
        Qmax = Qu * Href
    if 8<test<12:
        testn=test-9
        r0 = 300000.0 + 200000.0*testn
    if 11<test<15:
        testn=test-12
        RMW = 300000.0 + 200000.0*testn

    Runnumber = test
#-----> Rankine vortex
    for nx in range(0, nx_len):
       if rm[nx] <= RMW: 
          v[0,0,nx] = v1max_i * rm[nx] / RMW
          v[0,1,nx] = v2max_i * rm[nx] / RMW
          zeta[0,0,nx] = 2 * v1max_i / RMW
          zeta[0,1,nx] = 2 * v2max_i / RMW						#---> Why zeta is given by this?
      
       if rm[nx] > RMW: 
          v[0,0,nx] = v1max_i * RMW / rm[nx]
          v[0,1,nx] = v2max_i * RMW / rm[nx]
          zeta[0,0,nx] = 0.0
          zeta[0,1,nx] = 0.0

    for nlayer in range(nlayer_len):
       for nx in range(1,nx_len-1):
          rv[0,nlayer,nx] = rm[nx] * v[0,nlayer,nx]                                     #---> Initial relative vorticity?
      
    for nlayer in range(nlayer_len):
       for nx in range(nx_len):
          u[0,nlayer,nx] = 0							    #---> Initial radial velocity set to zero.

    #-----> Gradient wind balance at t=0
    h[0,0,-1] = Href 
    h[0,1,-1] = Href
    for nx in range(1,nx_len):
       dphi1 = (((v[0,0,-nx]*v[0,0,-nx])/rm[-nx]) + (f_cor*v[0,0,-nx])) * labda * (rm[-nx]+b)        #HERE ALSO MULTIPLY dx. BUT dx IS TAKEN AS 1. 
       dphi2 = (((v[0,1,-nx]*v[0,1,-nx])/rm[-nx]) + (f_cor*v[0,1,-nx])) * labda * (rm[-nx]+b) 
       dh2 = (1/((1-eps)*g)) * (dphi2 - dphi1)
       dh1 = (dphi1/g) - (eps*dh2)
       h[0,0,-nx-1] = h[0,0,-nx]-dh1
       h[0,1,-nx-1] = h[0,1,-nx]-dh2                                                    #---> So in the centre at beginnin H = Href 
                                                                                    #[I WOULD LIKE TO DO Href OUTSIDE THE CYCLONE]
    for nx in range (nx_len):
       geopot[0,0,nx] = g * (h[0,0,nx] + (eps * h[0,1,nx] ))
       geopot[0,1,nx] = g * (h[0,0,nx] + h[0,1,nx] )                                  #MISLUKE? h[0,1]+h[0,1]??

    ps0ref =  g * ((ro1 * Href) + (ro2 * Href)) # central surface pressure : reference state            ###I don't get, you calculate ps0ref but it's ps0[0]
    ps0[test,0] = g * ((ro1 * h[0,0,0]) + (ro2 * h[0,1,0])) # central surface pressure : initial state

    #############
    #-----> Specify forcing
    for nt in range(len(time)):
      for nx in range(nx_len):
         if time[nt]<=T_forcing: 
            M[nt,0,nx] = -(Qmax/T_forcing) * math.exp(-math.pow((r[nx]-r0)/a,2))     #*(time[nt]/T_forcing)        # layer 1			
            M[nt,1,nx] = (Qmax/(eps*T_forcing)) * math.exp(-math.pow((r[nx]-r0)/a,2))   #*(time[nt]/T_forcing)   # layer 1
         if time[nt]>T_forcing: 
            M[nt,0,nx] = 0.0
            M[nt,1,nx] = 0.0

    ##################################### ALGORITHM 

    for nt in range(1,len(time)):

      time[nt] = time[nt] / 3600.0  # time in hours    (NOT NECESSARY)
     
      #---> Compute the new height
      for nlayer in range(nlayer_len):
         for nx in range(1,nx_len-1):
            h[nt,nlayer,nx] = h[nt-1,nlayer,nx] - (dt * (Href / r[nx]) * ( c[nx]*((rm[nx+1]*u[nt-1,nlayer,nx+1])-(rm[nx]*u[nt-1,nlayer,nx]))) )   #This should be eq. 3 but 
            h[nt,nlayer,nx] = h[nt,nlayer,nx] + (dt * M[nt,nlayer,nx])     		                                #miss advection and H is taken constant as Href. 
         #--->Boundary conditions (ensure constant h at r=0 and r=+infty)
         h[nt,nlayer,0] = h[nt,nlayer,1]
         h[nt,nlayer,-1] = h[nt,nlayer,-2]

      #---> Compute the new geopotential
      for nx in range(nx_len):
         geopot[nt,0,nx] = g * (h[nt,0,nx] + (eps * h[nt,1,nx] ))
         geopot[nt,1,nx] = g * (h[nt,0,nx] + h[nt,1,nx] )
     
    # Compute the gradient wind, vgrad at x=1,2,3...   , i.e at the same grid points as geopotential and height (MISLUKE)
      for nx in range(1,nx_len-1):
         c1 = f_cor * r[nx]
         gradphi0 = c[nx] * (geopot[nt,0,nx+1]-geopot[nt,0,nx-1])/2  # radial gradient geopotential calculated on rm-grid
         gradphi1 = c[nx] * (geopot[nt,1,nx+1]-geopot[nt,1,nx-1])/2
         c2 = ((c1 * c1)+ (4*r[nx]*gradphi0))
         if c2>=0: vgrad[0,nx] = - 0.5 * (c1 - math.pow(c2,0.5))
         if c2<0: print('Problem with the gradient wind balance Layer 1',nt)
         c2 = ((c1 * c1)+ (4*r[nx]*gradphi1))
         if c2>=0: vgrad[1,nx] = - 0.5 * (c1 - math.pow(c2,0.5))
         if c2<0: print('Problem with the gradient wind balance Layer 2',nt)
    # Boundary condition
      vgrad[0,0] = 0.0
      vgrad[1,0] = 0.0

    # Compute balanced relative vorticity on intermediate points (at x=0.5,1.5,...
      for nx in range(1,nx_len-1):
         zeta[nt,0,nx] = (1/rm[nx]) * cm[nx] * ((rm[nx]*vgrad[0,nx]) - (rm[nx-1]*vgrad[0,nx-1]))
         zeta[nt,1,nx] = (1/rm[nx]) * cm[nx] * ((rm[nx]*vgrad[1,nx]) - (rm[nx-1]*vgrad[1,nx-1]))

    # v: forward (predictor) in time using previous value of u
    # u: Backward in time using new values of h and v
    # v: Backward (corrector) in time using new value of u
      for nlayer in range(nlayer_len):
         for nx in range(1,nx_len-1):
            v[nt,nlayer,nx] = v[nt-1,nlayer,nx] - ( dt * (f_cor + zeta[nt-1,nlayer,nx]) * u[nt-1,nlayer,nx])
            u[nt,nlayer,nx] = u[nt-1,nlayer,nx] - (dt * cm[nx] * (geopot[nt,nlayer,nx]-geopot[nt,nlayer,nx-1]))  # u & v on rm-grid
            u[nt,nlayer,nx] = u[nt,nlayer,nx] + (dt * f_cor * v[nt,nlayer,nx])
            u[nt,nlayer,nx] = u[nt,nlayer,nx] + (dt * v[nt,nlayer,nx] * v[nt,nlayer,nx] / rm[nx])
            v[nt,nlayer,nx] = v[nt-1,nlayer,nx] - ( dt * (f_cor + zeta[nt,nlayer,nx]) * u[nt,nlayer,nx])

    # Boundary conditions
      for nlayer in range(nlayer_len):
         u[nt,nlayer,-1] = u[nt,nlayer,-2]
         v[nt,nlayer,-1] = v[nt,nlayer,-2]
         u[nt,nlayer,0] = 0
         v[nt,nlayer,0] = 0

    # Backward (corrector) time step in h
      for nlayer in range(nlayer_len):
         for nx in range(2,nx_len-1):
            h[nt,nlayer,nx] = h[nt-1,nlayer,nx] - (dt * (Href / r[nx]) * ( c[nx]*((rm[nx+1]*u[nt,nlayer,nx+1])-(rm[nx]*u[nt,nlayer,nx]))) )   # h on r-grid
            h[nt,nlayer,nx] = h[nt,nlayer,nx] + (dt * M[nt,nlayer,nx])     

    # Boundary conditions
      for nlayer in range(nlayer_len):
         h[nt,nlayer,0] = h[nt,nlayer,1]
         h[nt,nlayer,-1] = h[nt,nlayer,-2]

      #########################
      ps0[test,nt] = g * ((ro1 * h[nt,0,0]) + (ro2 * h[nt,1,0])) # central surface pressure
      vmax[test,nt]= max(v[nt,0,:])
      if vmax[test,nt]==0.0:
          indexr=0
      else:
          indexr = npy.where(v[nt,0,:] == npy.amax(v[nt,0,:]))
      rvmax[test,nt]= r[indexr]
    #------------> BEGIN OUTPUT 
    #---> END OUTPUT 
    #---> END TIME LOOP
    
    #########################################################################################
        
# compute local internal Rossby radius
    RR = math.pow((1-eps)*g*Href,0.5)/(f_cor + (2 * v1max_i / RMW)) 

    nt = len(time) - 1 

    ### Compute the gradient wind, vgrad at the end of the run and plot both vgrad and v
    nt = len(time) - 1
    for nx in range(1,nx_len-1):
      c1 = f_cor * rm[nx]
      gradphi0 = cm[nx] * ((geopot[nt,0,nx]-geopot[nt,0,nx-1]))   # pressur gradient calculated on rm-grid
      gradphi1 = cm[nx] * ((geopot[nt,1,nx]-geopot[nt,1,nx-1]))
      c2 = ((c1 * c1)+ (4*rm[nx]*gradphi0))
      if c2>0: vgrad[0,nx] = - 0.5 * (c1 - math.pow(c2,0.5))
      if c2<0: print('Problem with the gradient wind balance Layer 1 - Final step')
      c2 = ((c1 * c1)+ (4*rm[nx]*gradphi1))
      if c2>0: vgrad[1,nx] = - 0.5 * (c1 - math.pow(c2,0.5))
      if c2<0: print('Problem with the gradient wind balance Layer 2 - Final step')

    # PLOT v and vgrad
    plt.figure(figsize=(8,6))

    if v1max_i>=0 and v1max_i<5.0: 
      plt.axis([0,4000,-10,10])
      plt.text(100,4.5,"t="+str(nt*dt/3600)+" hours")
      plt.text(100,4.0,"red: lower layer (v:thick; vgrad: thin)",color='red')
      plt.text(100,3.6,"blue: upper layer (v:thick; vgrad: thin)",color='blue')

    if v1max_i>=5.0: 
       plt.axis([0,4000,-2*v1max_i,2*v1max_i])
       plt.text(100,0.9*2*v1max_i,"t="+str(nt*dt/3600)+" hours") 
       plt.text(100,0.8*2*v1max_i,"red: lower layer (v:thick; vgrad: thin)",color='red')
       plt.text(100,0.72*2*v1max_i,"blue: upper layer (v:thick; vgrad: thin)",color='blue')

    plt.plot(rm[:]/1000, v[nt,0,:],linewidth=3.0, color='red')
    plt.plot(rm[:]/1000, v[nt,1,:],linewidth=3.0, color='blue')
    plt.plot(rm[:]/1000, vgrad[0,:],linewidth=1.0, color='red')
    plt.plot(rm[:]/1000, vgrad[1,:],linewidth=1.0, color='blue')

    plt.xlabel('radius [km]',fontsize=14)
    plt.ylabel('v [m/s]',fontsize=14) 

    plt.savefig(DirecOutputend+"GradientWind-Run"+str(Runnumber)+"with parameters="+str(Tf)+str(r0)+str(a)+str(Qmax)+str(RMW)+".png")
    plt.close()
    
    print(test,'done') 

os.system('say "your program has finished"')
T = npy.arange(0, end, dt) 
for i in range(0,5):
    if i==0:
    #plot different Tf
        tesx="Changing T_forcing"
        tx='T_forcing '
    if i==1:
    #plot different a
        tesx="Changing a"
        tx='a '
    if i==2:
    #plot different Qmax
        tesx="Changing Qmax"
        tx='Qmax '
    if i==3:
    #plot different r0
        tesx="Changing r0"
        tx='r0 '
    if i==4:
    #plot different RMW
        tesx="Changing RMW"
        tx='RMW '
        
    rtest0 = i*Ntest
    rtest1 = i*Ntest + Ntest-1
    # PLOT time-evolution of central surface pressure (surface = lower boundary)
    plt.figure(figsize=(8,6))
    for it in range(Ntest):
       plt.plot(T, ps0[i*Ntest + it,:],linewidth=2.0)
    plt.xlabel('time [hours]',fontsize=14)
    plt.ylabel('surface pressure deficit at r=0 [hPa]',fontsize=14)
    plt.title('P0 '+tesx)
    plt.legend([tx+str(1),tx+str(2),tx+str(3)],loc='upper right')
    plt.show()
    plt.savefig(DirecOutputpend+"ps0-Run"+str(Runnumber)+tesx+"with parameters="+str(Tf)+str(r0)+str(a)+str(Qmax)+str(RMW)+".png")
    plt.close()

    # PLOT time-evolution of max V lower layer
    plt.figure(figsize=(8,6))
    for it in range(Ntest):
       plt.plot(T, vmax[i*Ntest + it,:],linewidth=2.0)
    plt.xlabel('time [hours]',fontsize=14)
    plt.ylabel('max v [m/s]',fontsize=14)
    plt.title('vmax '+tesx)
    plt.legend([tx+str(1),tx+str(2),tx+str(3)], loc='upper right')
    plt.show()
    plt.savefig(DirecOutputvend+"vmax-Run"+str(Runnumber)+tesx+"with parameters="+str(Tf)+str(r0)+str(a)+str(Qmax)+str(RMW)+".png")

    plt.close()

    # PLOT time-evolution of  radious of max V lower layer
    plt.figure(figsize=(8,6))
    for it in range(Ntest):
       plt.plot(T, rvmax[i*Ntest + it,:],linewidth=2.0)
    plt.xlabel('time [hours]',fontsize=14)
    plt.ylabel('r of max v [m]',fontsize=14)
    plt.title('r of max v '+tesx)
    plt.legend([tx+str(1),tx+str(2),tx+str(3)], loc='upper right')
    plt.show()
    plt.savefig(DirecOutputrend+"rvmax-Run"+str(Runnumber)+tesx+"with parameters="+str(Tf)+str(r0)+str(a)+str(Qmax)+str(RMW)+".png")
    
    plt.close()
